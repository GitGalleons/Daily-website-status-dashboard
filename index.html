<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Daily Website Status Report</title>
  <link rel="stylesheet" href="style.css" />
  <!-- marked used to render Markdown to HTML -->
  <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
</head>
<body>
  <header class="site-header">
    <h1>Daily Website Status Report</h1>
    <p class="subtitle">Automatic daily checks and last saved report from <code>/reports/status.md</code></p>
    <div id="last-updated" class="last-updated" aria-live="polite"></div>
  </header>

  <main class="container">
    <div id="report" class="report">
      <p>Loading latest report...</p>
    </div>
  </main>

  <footer class="site-footer">
    <small>Generated by GitHub Actions &bull; Dashboard reads <code>/reports/status.md</code></small>
  </footer>

  <script>
    async function loadReport() {
      try {
        // Try relative path first. When served as raw files on GitHub or Pages this should work.
        const resp = await fetch('/reports/status.md', {cache: "no-store"});
        if (!resp.ok) {
          throw new Error('Failed to fetch /reports/status.md (status ' + resp.status + ')');
        }
        const md = await resp.text();
        // Extract a "Last updated" line (first lines) to show separately if exists
        const lines = md.split('\n').slice(0, 8).join('\n');
        const match = md.match(/Last updated:\s*(.+)/i);
        if (match && match[1]) {
          document.getElementById('last-updated').textContent = 'Last updated: ' + match[1].trim();
        } else {
          document.getElementById('last-updated').textContent = '';
        }

        const html = marked.parse(md);
        const container = document.getElementById('report');
        container.innerHTML = html;

        // Add status color classes to table rows
        document.querySelectorAll('table tbody tr').forEach(row => {
          const statusCell = row.querySelector('td[data-field="status-code"]');
          if (!statusCell) return;
          const codeText = statusCell.textContent.trim();
          let code = parseInt(codeText, 10);
          if (!Number.isFinite(code)) {
            row.classList.add('status-error');
          } else if (code >= 200 && code < 300) {
            row.classList.add('status-ok');
          } else if (code >= 300 && code < 400) {
            row.classList.add('status-redirect');
          } else {
            row.classList.add('status-error');
          }
        });

      } catch (err) {
        document.getElementById('report').innerHTML = '<p class="error">Could not load report: ' + err.message + '</p>';
        document.getElementById('last-updated').textContent = '';
      }
    }

    loadReport();

    // Optional: refresh every 5 minutes when this page is open
    setInterval(loadReport, 5 * 60 * 1000);
  </script>
</body>
</html>